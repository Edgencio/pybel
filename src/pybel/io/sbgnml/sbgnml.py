# -*- coding: utf-8 -*-

"""Convert SBGN-ML files generated by converting CellDesigner files with https://github.com/sbgn/cd2sbgnml.

Inspired by https://github.com/cannin/sbgn2sif.
"""

import itertools as itt
import logging
from collections import defaultdict
from xml.etree import ElementTree  # noqa:S405

import pyobo

from pybel import dsl
from pybel.io.sbgnml.constants import SBGN, chebi_name_to_id, go_name_to_id, hgnc_name_to_id
from pybel.io.sbgnml.utils import _get_label, _iter_references

logger = logging.getLogger(__name__)

DSL_MAPPING = {
    'simple molecule': dsl.Abundance,
    'macromolecule': dsl.Protein,
    'nucleic acid feature': dsl.Rna,
}


def parse(path: str):
    """Parse a SBGN-ML file."""
    # type: ElementTree
    tree = ElementTree.parse(path)  # noqa:S314
    root = tree.getroot()
    for sbgn_map in root.findall(f"{SBGN}map"):
        handle_sbgn_map(sbgn_map)


def handle_sbgn_map(sbgn_map):  # noqa: C901
    """Handle a map in an SBGN-ML XML element tree."""
    compartments = {}
    for compartment in sbgn_map.findall(f'{SBGN}glyph[@class="compartment"]'):
        compartment_id = compartment.get('id')
        compartment_label = compartment.findall(f'{SBGN}label')[0].get('text')

        go_id = None
        if compartment_label:
            go_id = go_name_to_id.get(compartment_label)
            if go_id is None:  # time to do NLP lol
                _, go_id, _ = pyobo.ground('go', compartment_label)
                if go_id:
                    compartment_label = pyobo.get_name('go', go_id)
            if not go_id:
                logger.warning('could not find GO cellular component %s %s', compartment_id, compartment_label)

        v = {
            'glyph_id': compartment_id,
            'entity': {
                'prefix': 'go',
                'identifier': go_id,
                'name': compartment_label,
            },
        }

        parent_compartment_id = compartment.get('compartmentRef')
        if parent_compartment_id:
            v['parent'] = parent_compartment_id

        compartments[compartment_id] = v

    port_to_process = {}
    process_to_ports = defaultdict(list)
    process_to_references = defaultdict(list)
    for process in sbgn_map.findall(f'{SBGN}glyph[@class="process"]'):
        process_id = process.get('id')
        process_to_references[process_id].extend(_iter_references(process))
        for port in process.findall(f'{SBGN}port'):
            port_id = port.get('id')
            process_to_ports[process_id].append(port_id)
            if port_id in port_to_process:
                logger.warning('rewriting port %s from %s to %s ', port_id, port_to_process[port_id], process_id)
            port_to_process[port_id] = process_id

    and_to_ports = defaultdict(list)
    ports_to_and = {}
    for and_glyph in sbgn_map.findall(f'{SBGN}glyph[@class="and"]'):
        and_id = and_glyph.get('id')
        for port in and_glyph.findall(f'{SBGN}port'):
            port_id = port.get('id')
            and_to_ports[and_id].append(port_id)
            if port_id in ports_to_and:
                logger.warning('rewriting port %s from %s to %s ', port_id, ports_to_and[port_id], and_id)
            ports_to_and[port_id] = and_id

    # id -> type, id, curie, label, (optional) states, (optional) compartment_id
    glyphs = {}

    # Build up phenotype glyphs
    for phenotype in sbgn_map.findall(f'{SBGN}glyph[@class="phenotype"]'):
        phenotype_glyph_id = phenotype.get('id')
        phenotype_label = _get_label(phenotype)

        _namespaces = ['go', 'efo']
        g_prefix, g_id, g_name = pyobo.multiground(_namespaces, phenotype_label)
        if g_id is None:
            logger.warning('could not look up phenotype %s %s', phenotype_glyph_id, phenotype_label)

        glyphs[phenotype_glyph_id] = {
            'glyph_id': phenotype_glyph_id,
            'class': 'phenotype',
            'entity': {
                'prefix': g_prefix,
                'identifier': g_id,
                'name': g_name,
            }
        }

    # Build up normal glyphs (and ones inside complexes)
    for glyph in itt.chain(
        sbgn_map.findall(f'{SBGN}glyph'),
        sbgn_map.findall(f'{SBGN}glyph[@class="complex"]/{SBGN}glyph'),
    ):
        glyph_class = glyph.get('class')
        if glyph_class is None:
            logger.warning('glyph missing class')
            continue
        if glyph_class in {'compartment', 'process', 'and'}:
            continue  # already handled

        if glyph_class in {'phenotype', 'complex', 'uncertain process'}:  # FIXME skip for now
            continue

        glyph_id = glyph.get('id')
        if glyph_id is None:
            logger.warning('glyph missing id')
            continue

        glyph_compartment_id = glyph.get('compartmentRef')
        glyph_compartment = compartments[glyph_compartment_id] if glyph_compartment_id else None

        label = _get_label(glyph)

        states = [
            state.get('value')
            for state in glyph.findall(f'{SBGN}glyph[@class="state variable"]/{SBGN}state')
            if state.get('value')
        ]  # TODO there's also the 'variable' entry which might tell you the position

        info = [
            state.get('text')
            for state in glyph.findall(f'{SBGN}glyph[@class="unit of information"]/{SBGN}label')
            if state.get('text')
        ]

        logger.info(
            '%s %s %s %s %s %s',
            glyph_class,
            glyph_id,
            label,
            f'in {glyph_compartment}' if glyph_compartment else '',
            f'with states: {states}' if states else '',
            f'with info: {info}' if info else '',
        )

        references = list(_iter_references(glyph))

        if not references and label in hgnc_name_to_id:
            references = [('hgnc', hgnc_name_to_id[label])]
        if not references and label in chebi_name_to_id:
            references = [('chebi', chebi_name_to_id[label])]
        elif not references:
            logger.warning('no references for %s %s %s', glyph_class, glyph_id, label)
        elif len(references) > 1 and glyph_class == 'macromolecule':
            logger.warning(
                '%s %s %s has multiple references. Should be a complex?',
                glyph_class,
                glyph_id,
                label,
            )
            glyph_class = 'complex'
        elif len(references) > 1:
            logger.warning(
                '%s %s %s has multiple references',
                glyph_class,
                glyph_id,
                label,
            )
            # TODO handle as complex

        glyphs[glyph_id] = {
            'glyph_id': glyph_id,
            'class': glyph_class,
            'entity': {
                'prefix': references[0][0] if references else None,
                'identifier': references[0][1] if references else None,
                'name': label,
            },
            'states': states,
            'compartment': glyph_compartment,
        }

    # Build up complexes
    for complex_glyph in sbgn_map.findall(f'{SBGN}glyph[@class="complex"]'):
        complex_id = complex_glyph.get('id')
        label = _get_label(complex_glyph)
        component_label_to_info = {}
        for component_label in label.split(':'):
            # make list of endings
            if component_label.endswith('-ubq'):  # ubiquitination
                component_label = component_label[:-len('-ubq')]
                component_identifier = hgnc_name_to_id.get(component_label)
                component_prefix = 'hgnc'
                tag = 'ubq'
            elif component_label.endswith('-P'):  # phosphorylated
                component_label = component_label[:-len('-P')]
                component_identifier = hgnc_name_to_id.get(component_label)
                component_prefix = 'hgnc'
                tag = 'P'
            elif component_label.endswith('*'):  # complex of family of genes with ascending numbers :)
                component_identifier = '?'
                component_prefix = '?'
                tag = None
            elif component_label in {'GTP', 'GDP', 'ATP', 'ADP'}:
                component_identifier = chebi_name_to_id.get(component_label)
                component_prefix = 'chebi'
                tag = None
            else:
                component_identifier = hgnc_name_to_id.get(component_label)
                component_prefix = 'hgnc'
                tag = None

            component_label_to_info[component_label] = {
                'glyph_id': complex_id,
                'entity': {
                    'prefix': component_prefix,
                    'identifier': component_identifier,
                    'name': component_label,
                },
                'tags': tag,
            }

        glyphs[complex_id] = {
            'glyph_id': complex_id,
            'label': label,
            'components': component_label_to_info,
        }

    # Build up arcs to processes
    arcs = {}
    successful = 0
    failures = 0
    for arc in sbgn_map.findall(f'{SBGN}arc'):
        arc_class = arc.get('class')
        if arc_class is None:
            logger.warning('arc has no class')
            failures += 1
            continue
        arc_id = arc.get('id')
        if arc_id is None:
            logger.warning('arc has no id')
            failures += 1
            continue
        arc_source_id = arc.get('source')
        if arc_source_id is None:
            logger.warning('arc:%s has no source', arc_source_id)
            failures += 1
            continue
        if arc_source_id in glyphs:
            arc_source = glyphs[arc_source_id]
        elif (
            arc_source_id in process_to_ports
            or arc_source_id in and_to_ports
        ):
            arc_source = arc_source_id
        elif arc_source_id in port_to_process:
            arc_source = port_to_process[arc_source_id]
        elif arc_source_id in ports_to_and:
            arc_source = ports_to_and[arc_source_id]
        else:
            logger.warning('can not find source %s', arc_source_id)
            failures += 1
            continue

        arc_target_id = arc.get('target')
        if arc_target_id is None:
            logger.warning('arc:%s has no target', arc_target_id)
            failures += 1
            continue
        if arc_target_id in glyphs:
            arc_target = glyphs[arc_target_id]
        elif (
            arc_target_id in process_to_ports
            or arc_target_id in and_to_ports
        ):
            arc_target = arc_target_id
        elif arc_target_id in port_to_process:
            arc_target = port_to_process[arc_target_id]
        elif arc_target_id in ports_to_and:
            arc_target = ports_to_and[arc_target_id]
        else:
            logger.warning('can not find target %s', arc_target_id)
            failures += 1
            continue

        successful += 1
        arcs[arc_id] = {
            'class': arc_class,
            'source': arc_source,
            'target': arc_target,
        }

    logger.warning('successful: %d / failure: %d', successful, failures)
    # print(json.dumps(arcs, indent=2))

    # just direct relations, can be added directly
    direct_stuff = {}
    # mediated by process
    process_to_input = {}
    process_to_output = {}

    for arc in arcs.values():
        # TODO just put this in previous loop
        arc_class = arc['class']
        arc_source = arc['source']
        arc_target = arc['target']

        if arc_class == 'production' and isinstance(arc_source, str) and isinstance(arc_target, dict):
            logger.info('handling production from %s to %s', arc_source, arc_target['glyph_id'])

        elif arc_class == 'consumption' and isinstance(arc_source, dict) and isinstance(arc_target, str):
            logger.info('handling consumption from %s to %s', arc_source['glyph_id'], arc_target)

        elif arc_class == 'catalysis' and isinstance(arc_source, dict) and isinstance(arc_target, str):
            logger.info('handling catalysis from %s on %s', arc_source['glyph_id'], arc_target)

        elif arc_class == 'catalysis' and isinstance(arc_source, str) and isinstance(arc_target, str):
            logger.warning('unhandled process->process catalysis')

        elif arc_class == 'inhibition' and isinstance(arc_source, dict) and isinstance(arc_target, str):
            logger.info('handling inhibition of process from %s to %s', arc_source['glyph_id'], arc_target)

        elif arc_class == 'inhibition' and isinstance(arc_source, dict) and isinstance(arc_target, dict):
            logger.info('handling direct inhibition from %s to %s', arc_source['glyph_id'], arc_target['glyph_id'])

        elif arc_class == 'stimulation' and isinstance(arc_source, dict) and isinstance(arc_target, dict):
            logger.info('handling direct stimulation from %s to %s', arc_source['glyph_id'], arc_target['glyph_id'])

        elif arc_class == 'logic arc' and isinstance(arc_source, dict) and isinstance(arc_target, str):
            logger.info('handling AND relation on process %s', arc_target)

        else:
            logger.warning(
                '[%s] unhandled arc class with source=%s target=%s\n%s\n%s',
                arc_class, type(arc_source), type(arc_target),
                arc_source, arc_target
            )


def _main():
    parse('ER_Stress_Cov19.xml')


if __name__ == '__main__':
    logging.basicConfig(
        level=logging.WARNING,
        format='[%(asctime)s] %(levelname)-8s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
    )
    _main()
